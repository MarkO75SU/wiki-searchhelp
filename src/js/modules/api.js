// src/js/modules/api.js
import { showToast } from './toast.js';
import { getTranslation } from './state.js';

/**
 * Parses the generated search query to separate recognized parameters from the main search term.
 * @param {string} query - The full search query string generated by the user.
 * @returns {object} An object containing parsed parameters.
 */
function parseAdvancedSearchParams(query) {
    const params = {
        srsearch: query,
        srincategory: '',
        deepcategory: '',
        srhastemplate: '',
        srprefix: '',
        srincontent: '', // Corresponds to insource
        srfiletype: ''
    };

    let currentQuery = query; // Use a distinct variable to track the evolving query string

    const definitions = {
        srincategory: { regex: /incategory:("([^"]*?)"|([^\s]+))/gi, separator: '|' }, // Global regex
        deepcategory: { regex: /deepcat:("([^"]*?)"|([^\s]+))/gi },
        srhastemplate: { regex: /hastemplate:("([^"]*?)"|([^\s]+))/gi },
        srprefix: { regex: /prefix:("([^"]*?)"|([^\s]+))/gi },
        srincontent: { regex: /insource:("([^"]*?)"|([^\s]+))/gi },
        srfiletype: { regex: /filetype:("([^"]*?)"|([^\s]+))/gi }
    };

    for (const paramKey in definitions) {
        const { regex, separator } = definitions[paramKey];
        let values = [];

        // Find all matches for the current parameter type
        const matches = [...currentQuery.matchAll(regex)]; // Get all matches

        matches.forEach(match => {
            const value = match[2] || match[3]; // Quoted or unquoted value
            if (value) {
                values.push(value);
            }
        });

        if (values.length > 0) {
            params[paramKey] = values.join(separator || ' '); // Join with separator or space
        }

        // Remove ALL occurrences of this parameter from the query string
        currentQuery = currentQuery.replace(regex, '').trim();
    }

    params.srsearch = currentQuery.trim(); // The remainder is the core search string

    return params;
}

/**
 * Generic helper for Wikipedia API fetches with error handling.
 */
export async function fetchWikiData(lang, params) {
    const endpoint = `https://${lang}.wikipedia.org/w/api.php`;
    const queryParams = new URLSearchParams({
        format: 'json',
        origin: '*',
        ...params
    });
    
    try {
        const response = await fetch(`${endpoint}?${queryParams}`);
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        return await response.json();
    } catch (error) {
        console.error("Wikipedia API fetch error:", error);
        showToast(getTranslation('error-api-fetch') || 'Could not fetch data from Wikipedia API.');
        return null;
    }
}

/**
 * Performs a search on the Wikipedia API.
 */
export async function performWikipediaSearch(query, lang = 'de', limit = 10) {
    return await fetchWikiData(lang, {
        action: 'query',
        list: 'search',
        srsearch: query,
        srlimit: limit,
        prop: 'pageimages',
        piprop: 'thumbnail',
        pithumbsize: 150
    });
}

/**
 * Helper to batch API requests for large lists of titles.
 * @param {string[]} titles - All titles to fetch.
 * @param {string} lang - Language code.
 * @param {Function} fetchFunction - The function to call for each batch (must accept titles, lang).
 * @returns {Promise<Object>} Aggregated results from all batches.
 */
async function fetchBatchedData(titles, lang, fetchFunction) {
    const batchSize = 50;
    let aggregatedResults = {};
    
    // For arrays (like from search), we might need to handle array concatenation instead of object merging
    // But most detail fetches return objects keyed by pageId or title.
    
    for (let i = 0; i < titles.length; i += batchSize) {
        const batch = titles.slice(i, i + batchSize);
        try {
            const result = await fetchFunction(batch, lang);
            if (result) {
                // If result is query.pages object
                if (result.query && result.query.pages) {
                    Object.assign(aggregatedResults, result.query.pages);
                } 
                // If result is a direct object map (custom return from some functions)
                else {
                    Object.assign(aggregatedResults, result);
                }
            }
        } catch (e) {
            console.error("Batch fetch error:", e);
        }
    }
    return aggregatedResults;
}

/**
 * Fetches additional info (like images) for specific titles.
 */
export async function fetchArticlesInfo(titles, lang = 'de') {
    // Internal batch fetcher
    const _fetch = async (batchTitles, l) => {
        return await fetchWikiData(l, {
            action: 'query',
            titles: batchTitles.join('|'),
            prop: 'pageimages',
            piprop: 'thumbnail',
            pithumbsize: 150
        });
    };

    if (titles.length > 50) {
        const pages = await fetchBatchedData(titles, lang, _fetch);
        return { query: { pages: pages } }; // Reconstruct expected format
    }

    return await _fetch(titles, lang);
}

/**
 * Fetches a brief summary for a given article title.
 */
export async function fetchArticleSummary(title, lang) {
    const data = await fetchWikiData(lang, {
        action: 'query',
        prop: 'extracts',
        exsentences: 10,
        exintro: true,
        explaintext: true,
        titles: title
    });

    if (!data) return "Summary could not be retrieved.";
    
    const pages = data.query.pages;
    const pageId = Object.keys(pages)[0];
    if (pageId === "-1" || !pages[pageId].extract) {
        return "No summary available.";
    }
    return pages[pageId].extract;
}

/**
 * Fetches summaries for multiple articles in one batch.
 */
export async function fetchArticlesSummaries(titles, lang) {
    const _fetch = async (batchTitles, l) => {
        return await fetchWikiData(l, {
            action: 'query',
            prop: 'extracts',
            exsentences: 3, 
            exintro: true,
            explaintext: true,
            titles: batchTitles.join('|'),
            exlimit: batchTitles.length
        });
    };

    if (titles.length > 50) {
        const pages = await fetchBatchedData(titles, lang, _fetch);
        return pages; // fetchArticlesSummaries returns pages object directly
    }

    const data = await _fetch(titles, lang);
    if (!data || !data.query || !data.query.pages) return {};
    return data.query.pages;
}

/**
 * Fetches categories for multiple articles in batches.
 */
export async function fetchArticlesCategories(titles, lang, onProgress) {
    const batchSize = 50;
    const allPages = {};

    for (let i = 0; i < titles.length; i += batchSize) {
        const batchTitles = titles.slice(i, i + batchSize);
        if (onProgress) onProgress(i, titles.length);
        
        const data = await fetchWikiData(lang, {
            action: 'query',
            titles: batchTitles.join('|'),
            prop: 'categories',
            cllimit: 50,
            clshow: '!hidden'
        });

        if (data && data.query && data.query.pages) {
            Object.assign(allPages, data.query.pages);
        }
    }
    return allPages;
}

/**
 * Fetches a resource from a given URL and returns it as text.
 * @param {string} url - The URL of the resource to fetch.
 * @returns {Promise<string|null>} The resource as text, or null on error.
 */
export async function fetchResource(url) {
    try {
        const response = await fetch(url);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        return await response.text();
    } catch (error) {
        console.error(`Error fetching resource from ${url}:`, error);
        showToast(getTranslation('error-resource-fetch') || 'Could not fetch resource.');
        return null;
    }
}

/**
 * Fetches JSON data from a given URL.
 * @param {string} url - The URL to fetch JSON from.
 * @returns {Promise<object|null>} The JSON data, or null on error.
 */
export async function fetchJson(url) {
    try {
        const response = await fetch(url);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        return await response.json();
    } catch (error) {
        console.error(`Error fetching JSON from ${url}:`, error);
        showToast(getTranslation('error-json-fetch') || 'Could not fetch JSON data.');
        return null;
    }
}

/**
 * Fetches search suggestions from Wikipedia's OpenSearch API.
 * @param {string} query - The search query.
 * @param {string} lang - The Wikipedia language edition.
 * @param {number} limit - The maximum number of suggestions to return.
 * @returns {Promise<Array|null>} An array of suggestions, or null on error.
 */
export async function fetchWikipediaOpenSearch(query, lang = 'de', limit = 10) {
    const params = {
        action: 'opensearch',
        search: query,
        limit: limit,
    };
    // fetchWikiData is not used here because opensearch has a different response format.
    const endpoint = `https://${lang}.wikipedia.org/w/api.php`;
    const queryParams = new URLSearchParams({
        format: 'json',
        origin: '*',
        ...params
    });
    
    try {
        const response = await fetch(`${endpoint}?${queryParams}`);
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        return await response.json();
    } catch (error) {
        console.error("Wikipedia OpenSearch fetch error:", error);
        showToast(getTranslation('error-opensearch-fetch') || 'Could not fetch search suggestions.');
        return null;
    }
}

/**
 * Fetches the last modification timestamp for given article titles.
 * @param {string[]} titles - An array of article titles.
 * @param {string} lang - The Wikipedia language edition.
 * @returns {Promise<object|null>} An object mapping titles to their last modification timestamps, or null on error.
 */
export async function fetchArticleModificationDates(titles, lang = 'de') {
    if (titles.length === 0) return {};

    const _fetch = async (batchTitles, l) => {
        const data = await fetchWikiData(l, {
            action: 'query',
            prop: 'revisions',
            rvprop: 'timestamp',
            titles: batchTitles.join('|')
        });
        
        if (!data || !data.query || !data.query.pages) return {};
        
        const batchDates = {};
        for (const pageId in data.query.pages) {
            const page = data.query.pages[pageId];
            if (page.revisions && page.revisions.length > 0) {
                batchDates[page.title] = page.revisions[0].timestamp;
            }
        }
        return batchDates;
    };

    if (titles.length > 50) {
        return await fetchBatchedData(titles, lang, _fetch);
    }

    return await _fetch(titles, lang);
}

/**
 * Fetches geographical coordinates for given article titles.
 * @param {string[]} titles - An array of article titles.
 * @param {string} lang - The Wikipedia language edition.
 * @returns {Promise<object|null>} An object mapping titles to their coordinates ({lat, lon}), or null on error.
 */
export async function fetchArticleCoordinates(titles, lang = 'de') {
    if (titles.length === 0) return {};

    const _fetch = async (batchTitles, l) => {
        const data = await fetchWikiData(l, {
            action: 'query',
            prop: 'coordinates',
            titles: batchTitles.join('|'),
            colimit: 50 // Limit the number of coordinates per request
        });

        if (!data || !data.query || !data.query.pages) return {};

        const batchCoords = {};
        for (const pageId in data.query.pages) {
            const page = data.query.pages[pageId];
            if (page.coordinates && page.coordinates.length > 0) {
                batchCoords[page.title] = {
                    lat: page.coordinates[0].lat,
                    lon: page.coordinates[0].lon
                };
            }
        }
        return batchCoords;
    };

    if (titles.length > 50) {
        return await fetchBatchedData(titles, lang, _fetch);
    }

    return await _fetch(titles, lang);
}

/**
 * Fetches quality metrics (like external links) for article titles.
 */
export async function fetchQualityMetrics(titles, lang = 'de') {
    if (titles.length === 0) return {};
    
    const _fetch = async (batchTitles, l) => {
        const data = await fetchWikiData(l, {
            action: 'query',
            prop: 'extlinks|info',
            titles: batchTitles.join('|'),
            ellimit: 50 
        });
        
        if (!data || !data.query || !data.query.pages) return {};
        return data.query.pages;
    };

    return await fetchBatchedData(titles, lang, _fetch);
}

/**
 * Fetches interwiki links (links to the same article in other languages).
 */
export async function fetchInterwikiLinks(titles, lang = 'de') {
    if (titles.length === 0) return {};
    
    const _fetch = async (batchTitles, l) => {
        const data = await fetchWikiData(l, {
            action: 'query',
            prop: 'langlinks',
            titles: batchTitles.join('|'),
            lllimit: 50
        });
        
        if (!data || !data.query || !data.query.pages) return {};
        return data.query.pages;
    };

    return await fetchBatchedData(titles, lang, _fetch);
}

/**
 * Validates coordinates using the Photon (Komoot) reverse geocoding API.
 */
export async function validateWithOSM(lat, lon) {
    const url = `https://photon.komoot.io/reverse?lon=${lon}&lat=${lat}`;
    try {
        const response = await fetch(url);
        const data = await response.json();
        return data.features && data.features.length > 0 ? data.features[0].properties.name : "Unbekannter Ort";
    } catch (e) {
        console.error("OSM Validierung fehlgeschlagen", e);
        return null;
    }
}

/**
 * Fetches the wikitext of articles and counts the number of <ref> tags.
 * This provides a more accurate measure of "citation density" than just counting external links.
 * @param {string[]} titles - Array of article titles.
 * @param {string} lang - Language code.
 * @returns {Promise<object>} Map of title -> refCount
 */
export async function fetchRefCounts(titles, lang = 'de') {
    if (titles.length === 0) return {};

    const _fetch = async (batchTitles, l) => {
        const data = await fetchWikiData(l, {
            action: 'query',
            prop: 'revisions',
            rvprop: 'content', // Fetch the actual wikitext
            rvslots: 'main',
            titles: batchTitles.join('|')
        });

        if (!data || !data.query || !data.query.pages) return {};

        const batchCounts = {};
        for (const pageId in data.query.pages) {
            const page = data.query.pages[pageId];
            let refCount = 0;
            
            // Access the content securely
            const content = page.revisions?.[0]?.slots?.main?.['*'];
            
            if (content) {
                // Regex to match <ref> tags (case-insensitive)
                // We count both <ref>...</ref> and <ref name="..." />
                const matches = content.match(/<ref/gi);
                refCount = matches ? matches.length : 0;
            }
            batchCounts[page.title] = refCount;
        }
        return batchCounts;
    };

    if (titles.length > 50) {
        return await fetchBatchedData(titles, lang, _fetch);
    }

    return await _fetch(titles, lang);
}
