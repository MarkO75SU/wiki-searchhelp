// src/js/modules/api.js

/**
 * Parses the generated search query to separate recognized parameters from the main search term.
 * @param {string} query - The full search query string generated by the user.
 * @returns {object} An object containing parsed parameters.
 */
function parseAdvancedSearchParams(query) {
    const params = {
        srsearch: query, // Initialize with the full query
        srincategory: '',
        srdeepcategory: '',
        srhastemplate: '',
        srprefix: '',
        srincontent: '', // Corresponds to insource
        srfiletype: ''
    };

    let remainingQuery = query;

    // Define patterns for advanced parameters that should be moved out of srsearch
    // Use non-greedy match for quoted strings: "([^"]*?)"
    // Or match non-whitespace for unquoted: ([^\s]+)
    const patterns = {
        srincategory: /incategory:("([^"]*?)"|([^\s]+))/i,
        srdeepcategory: /deepcat:("([^"]*?)"|([^\s]+))/i,
        srhastemplate: /hastemplate:("([^"]*?)"|([^\s]+))/i,
        srprefix: /prefix:("([^"]*?)"|([^\s]+))/i,
        srincontent: /insource:("([^"]*?)"|([^\s]+))/i, // 'insource' maps to 'srincontent'
        srfiletype: /filetype:("([^"]*?)"|([^\s]+))/i
    };

    for (const paramKey in patterns) {
        let match;
        // Keep matching and replacing until no more occurrences of this parameter are found
        // Use a global regex to find all matches, but process one by one to ensure removal
        while ((match = remainingQuery.match(patterns[paramKey]))) {
            // Group 2 is for quoted string, Group 3 is for unquoted string
            const value = match[2] || match[3];
            if (value) {
                // If there are multiple values for a single parameter (e.g. incategory:A incategory:B),
                // we should concatenate them or handle based on API expectations.
                // For now, assuming only one of each is intended for simple parsing.
                // For incategory, the API expects semicolon-separated values if multiple.
                if (paramKey === 'srincategory' && params[paramKey]) {
                    params[paramKey] += ';' + value;
                } else if (params[paramKey]) { // For other params, just overwrite if multiple occurrences exist
                    params[paramKey] = value;
                } else {
                    params[paramKey] = value;
                }
            }
            // Remove the matched part from the remaining query string
            remainingQuery = remainingQuery.replace(match[0], '').trim();
        }
    }

    // After extracting dedicated parameters, the rest of the remainingQuery becomes srsearch
    params.srsearch = remainingQuery.trim();

    return params;
}

/**
 * Performs a search on the Wikipedia API.
 * @param {string} query - The search query string.
 * @param {string} lang - The language of the Wikipedia to search.
 * @returns {Promise<object>} A promise that resolves to the full API response object.
 */
export async function performWikipediaSearch(query, lang) {
    const endpoint = `https://${lang}.wikipedia.org/w/api.php`;
    const parsedParams = parseAdvancedSearchParams(query);
    console.log("DEBUG: Parsed API parameters:", parsedParams); // DEBUG

    const apiParams = {
        action: 'query',
        list: 'search',
        format: 'json',
        origin: '*',
        srinfo: 'totalhits', // Request totalhits for display
        ...parsedParams
    };
    
    // Remove any empty parameters to keep the URL clean
    Object.keys(apiParams).forEach(key => {
        if (!apiParams[key]) {
            delete apiParams[key];
        }
    });

    const params = new URLSearchParams(apiParams);
    const url = `${endpoint}?${params}`;
    console.log("Wikipedia Search API URL:", url);

    try {
        const response = await fetch(url);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        return await response.json();
    } catch (error) {
        console.error("Error during Wikipedia search:", error);
        return { query: { search: [], searchinfo: { totalhits: 0 } } };
    }
}

/**
 * Fetches a brief summary for a given article title.
 * @param {string} title - The title of the article.
 * @param {string} lang - The language of the Wikipedia.
 * @returns {Promise<string>} A promise that resolves to the article summary.
 */
export async function fetchArticleSummary(title, lang) {
    const endpoint = `https://${lang}.wikipedia.org/w/api.php`;
    const params = new URLSearchParams({
        action: 'query',
        prop: 'extracts',
        exintro: true,
        explaintext: true,
        titles: title,
        format: 'json',
        origin: '*'
    });
    const url = `${endpoint}?${params}`;

    try {
        const response = await fetch(url);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();
        const pages = data.query.pages;
        const pageId = Object.keys(pages)[0];
        if (pageId === "-1" || !pages[pageId].extract) {
            return "No summary available.";
        }
        return pages[pageId].extract;
    } catch (error) {
        console.error(`Could not fetch summary for ${title}:`, error);
        return "Summary could not be retrieved.";
    }
}
